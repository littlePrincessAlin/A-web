import HocExample1 from './HocExample1.js';

const Hoc = () => {
  return (
    <>
      <h1>效果：</h1>
      hocExample： 一个登陆鉴权的小例子；<br/>
      hocExample1： 一个渲染劫持的小例子；<br/>
      <HocExample1/>
      <hr />
      <h1>hoc(高阶组件): </h1>
      <b>首先高阶？</b><br/>
      在数学上有一个名词叫高阶微分方程，我们可以利用求导来对其进行降阶。同理高阶组件（功能：接收一个或多个组件，返回一个组件），
      接收的参数也可以是高阶组件，因此这样一层层的嵌套，才称为“高阶”组件的。本质就是纯函数。
      <h2>使用举例</h2>
      <ul>
        <li>1、常见的使用场景：权限控制、日志记录、数据校验、异常处理、统计上报、拦截渲染等</li>
        <li>2、常见的高阶组件: redux的connect 等</li>
      </ul>
      <h2>redux的connect</h2>
        
      <h2>hoc缺点：</h2>
      <h3>很难复用逻辑，会导致组件树层级很深</h3>
      高阶组件和 Render Props 本质上都是将复用逻辑提升到父组件中，很容易产生很多包装组件，带来的「嵌套地域」。由于所有抽象逻辑都被其他 React 组件所隐藏，应用变成了一棵没有可读性的组件树。而那些可见的组件也很难在浏览器的 DOM 中进行跟踪。
      <h3>业务逻辑分散在组件的各个方法中</h3>
      <h3>hoc包装后的组件props会和传入的props重名</h3>
      <h3>难以理解的class</h3>
      class 组件有很多缺陷：
      <ul>
        <li>1、不同的生命周期会使逻辑变得分散混乱，不易维护和管理</li>
        <li>2、时刻需要关注this指向问题</li>
        <li>3、代码复用代价高，高阶组件的使用会使整个组件树变得臃肿</li>
        <li>4、在《设计模式》这本书中讲到了，组合 远优于 继承，class就是使用的继承</li>
      </ul>
      因此react提出了更易于学习的----hooks～ <br></br>
      对于跨组件复用来说，hooks作为官方底层api，最为轻量，改造成本较小，不回影响原来的组件层次结构和传说的嵌套地狱。<br></br>
      如果抽离为一个自定义hooks更容易使状态和ui隔离开。
    </>
  );
};

export default Hoc;
